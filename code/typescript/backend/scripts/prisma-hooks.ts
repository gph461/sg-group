import { getDMMF } from '@prisma/internals';
import { mkdirSync, readFileSync, readdirSync, writeFileSync } from 'fs';
import path from 'path';

const header = `/* eslint-disable prettier/prettier */\n// This file was generated by a custom prisma generator, do not edit manually.\n`;

interface Job {
  name: string;
  run: () => Promise<void>;
}

async function main() {
  const schemas = readdirSync('./prisma/schema');
  let prismaContent = '';

  for (const s of schemas) {
    const content = readFileSync(`./prisma/schema/${s}`, 'utf-8');
    prismaContent += `\n${content}`;
  }

  const dmmf = await getDMMF({
    datamodel: prismaContent,
  });

  const jobs: Job[] = [
    {
      name: 'Generate enums file',
      run: async () => {
        const output = dmmf.datamodel.enums.map((e) => {
          let enumString = `export const ${e.name} = {\n`;
          e.values.forEach(({ name: value }) => {
            enumString += `  ${value}: "${value}",\n`;
          });
          enumString += `} as const;\n\n`;
          enumString += `export type ${e.name} = (typeof ${e.name})[keyof typeof ${e.name}];\n`;

          return enumString;
        });

        const outputPath = path.resolve('./libs/entities/enums.ts');
        mkdirSync(path.dirname(outputPath), { recursive: true });
        writeFileSync(outputPath, header + output.join('\n'), 'utf-8');
      },
    },
    {
      name: 'Checking models for missing dbName',
      run: async () => {
        const missingDbName = dmmf.datamodel.models.filter(
          (model) => !model.dbName,
        );

        if (missingDbName.length > 0) {
          console.error(
            `\nThe following models are missing @@map fields: ${missingDbName
              .map((model) => model.name)
              .join(', ')}`,
          );
          process.exit(1);
        }
      },
    },
    // {
    //   name: 'Checking relations for proper pluralization',
    //   run: async () => {
    //     const models = models;
    //     const relations = models.flatMap((model) =>
    //       model.fields.filter((f) => f.kind === 'object' && f.isList),
    //     );

    //     function getPluralizedType(model: DMMF.Model, type: string) {
    //       // UserSessions of User becomes Sessions
    //       return pluralize(type, 2).replace(model.name, '');
    //     }

    //     const relationsNotPlural = relations.filter((relation) => {
    //       const model = getModelByField(relation, dmmf);
    //       if (!model) return false;
    //       return getPluralizedType(model, relation.type) !== relation.name;
    //     });

    //     if (relationsNotPlural.length > 0) {
    //       console.error(
    //         `\nThe following property are not properly pluralized, make changes to it${relationsNotPlural
    //           .map((relation) => {
    //             const fieldModel = getModelByField(relation, dmmf);

    //             if (!fieldModel) return '';

    //             return `\n${fieldModel.name}.${relation.name} -> ${
    //               fieldModel.name
    //             }.${getPluralizedType(fieldModel, relation.type)}`;
    //           })
    //           .join()}`,
    //       );
    //       process.exit(1);
    //     }
    //   },
    // },
  ];

  for (const job of jobs) {
    console.log(`Running job: ${job.name}`);
    await job.run();
  }
}
main();
